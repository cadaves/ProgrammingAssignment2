amtrix$get()
amatrix$get()
makeCacheMatrix <- function(x = matrix()) {
mx <- NULL                         ## initializes matrix object
set <- function(y) {
x <<- y
mx <<- NULL
}
get <- function() {
x                  ## Prints the value of matrix x
}
setinverse <- function(inverse) {
mx <<- inverse
}
getinverse <- function() {
mx
}
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
amatrix$set(matrix(c(0,5,99,66), nrow=2, ncol=2)) # Modify existing matrix
amatrix$get()
amatrix = makeCacheMatrix(matrix(c(1,2,3,4), nrow=2, ncol=2))
amtatrix$get()
amatrix$get()
makeCacheMatrix <- function(x = matrix()) {
mx <- NULL                         ## initializes matrix object
set <- function(y) {
x <<- y
mx <<- NULL
}
get <- function() {
x                  ## Prints the value of matrix x
}
setinverse <- function(inverse) {
mx <<- inverse
}
getinverse <- function() {
mx
}
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## This function checks to see if the inverse of the matrix has
## already been calculated.  If it has, it will access the inverse
## from the cache and print it.  If it has not, it will solve for
## the inverse and then print it.
cacheSolve <- function(x, ...) {
m <- x$getinverse()
if(!is.null(mx)) {
message("getting cached data")
return(mx)
}
data <- x$get()
mx <- solve(data, ...)          ## Calculates inverse. For this
## assignment, assuming a square mx
x$setinverse(mx)
mx
}
## Return a matrix that is the inverse of 'x'
}
makeCacheMatrix <- function(x = matrix()) {
mx <- NULL                         ## initializes matrix object
set <- function(y) {
x <<- y
mx <<- NULL
}
get <- function() {
x                  ## Prints the value of matrix x
}
setinverse <- function(inverse) {
mx <<- inverse
}
getinverse <- function() {
mx
}
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## This function checks to see if the inverse of the matrix has
## already been calculated.  If it has, it will access the inverse
## from the cache and print it.  If it has not, it will solve for
## the inverse and then print it.
cacheSolve <- function(x, ...) {
m <- x$getinverse()
if(!is.null(mx)) {
message("getting cached data")
return(mx)
}
data <- x$get()
mx <- solve(data, ...)          ## Calculates inverse. For this
## assignment, assuming a square mx
x$setinverse(mx)
mx
## Return a matrix that is the inverse of 'x'
}
amatrix = makeCacheMatrix(matrix(c(1,2,3,4), nrow=2, ncol=2))
amatrix$get()
cacheSolve(amatrix)
makeCacheMatrix <- function(x = matrix()) {
mx <- NULL                         ## initializes matrix object
set <- function(y) {
x <<- y
mx <<- NULL
}
get <- function() {
x                  ## Prints the value of matrix x
}
setinverse <- function(inverse) {
mx <<- inverse
}
getinverse <- function() {
mx
}
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## This function checks to see if the inverse of the matrix has
## already been calculated.  If it has, it will access the inverse
## from the cache and print it.  If it has not, it will solve for
## the inverse and then print it.
cacheSolve <- function(x, ...) {
mx <- x$getinverse()
if(!is.null(mx)) {
message("getting cached data")
return(mx)
}
data <- x$get()
mx <- solve(data, ...)          ## Calculates inverse. For this
## assignment, assuming a square mx
x$setinverse(mx)
mx
## Return a matrix that is the inverse of 'x'
}
amatrix = makeCacheMatrix(matrix(c(1,2,3,4), nrow=2, ncol=2))
amtrarix$get()
amatrix$get()
cacheSolve(amatrix)
amatrix$getinverse()  # Returns matrix inverse
cacheSolve(amatrix)
amatrix$set(matrix(c(0,5,99,66), nrow=2, ncol=2)) # Modify existing matrix
cacheSolve(amatrix)
amatrix$get()
amatrix$getinverse()
m<-makeCacheMatrix(matrix(1:4,2,2))
amatrix<-makeCacheMatrix(matrix(1:4,2,2))
amatrix$get()
cacehSolve(amatrix)
cacheSolve(amatrix)
cacheSolve(amatrix)
dim(amatrix)
mx
source("cacehmatrix.R")
source("cachematrix.R")
amatrix = makeCacheMatrix(matrix(1:9,nrow=3,ncol=3))
amatrix$get()
cacheSolve(amatrix)
amatrix = makeCacheMatrix(matrix(2:10,nrow=3,ncol=3))
amatrix$get()
cacheSolve(amatrix)
amatrix$set(matrix(c(1,2,3,6,5,4,9,7,8),3,3,byrow=T))
amatrix$get()
cacheSolve(amatrix)
cacheSolve(amatrix)
source('~/GitHub/Coursera-R-programming/ProgrammingAssignment2/cachematrix.R')
source('~/GitHub/Coursera-R-programming/ProgrammingAssignment2/cachematrix.R')
makeCacheMatrix <- function(x = matrix()) {
mx <- NULL                         ## initializes matrix object
set <- function(y) {
x <<- y
mx <<- NULL
}
get <- function() {
x                  ## Returns the value of matrix x
}
setinverse <- function(inverse) {
mx <<- inverse
}
getinverse <- function() {
mx
}
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The function cacheSolve checks to see if the inverse of the matrix has
## already been calculated.  If it has, it will access the inverse
## from the cache and print it.  If it has not, it will solve for
## the inverse and then print it. Note that this assignment assumed that the
## matrix would be a square one, and, thus, possible to calcualte the inverse.
## If the matrix is singular (determinant =0), then the solve function will
## return an error message.
cacheSolve <- function(x, ...) {
mx <- x$getinverse()
if(!is.null(mx)) {                       ##inverse already calculated?
message("getting cached data")   ##if yes, then gets cached inverse
return(mx)
}
data <- x$get()
mx <- solve(data, ...)          ## Else, calculates inverse. For this
## assignment, assuming a square mx
x$setinverse(mx)
mx
## Return a matrix that is the inverse of 'x'
}
makeCacheMatrix <- function(x = matrix()) {
mx <- NULL                         ## initializes matrix object
set <- function(y) {
x <<- y
mx <<- NULL
}
get <- function() {
x                  ## Returns the value of matrix x
}
setinverse <- function(inverse) {
mx <<- inverse
}
getinverse <- function() {
mx
}
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The function cacheSolve checks to see if the inverse of the matrix has
## already been calculated.  If it has, it will access the inverse
## from the cache and print it.  If it has not, it will solve for
## the inverse and then print it. Note that this assignment assumed that the
## matrix would be a square one, and, thus, possible to calcualte the inverse.
## If the matrix is singular (determinant =0), then the solve function will
## return an error message.
cacheSolve <- function(x, ...) {
mx <- x$getinverse()
if(!is.null(mx)) {                       ##inverse already calculated?
message("getting cached data")   ##if yes, then gets cached inverse
return(mx)
}
data <- x$get()
dim(data)
print("dimensions dataset")
mx <- solve(data, ...)          ## Else, calculates inverse. For this
## assignment, assuming a square mx
x$setinverse(mx)
mx
## Return a matrix that is the inverse of 'x'
}
amatrix = makeCacheMatrix(matrix(c(1,2,3,4), nrow=2, ncol=2))
amatrix$get()
cacheSolve(amatrix)
nrow <- nrow(matrix)
nrow
nrow <- nrow(amatrix)
nrow
makeCacheMatrix <- function(x = matrix()) {
mx <- NULL                         ## initializes matrix object
set <- function(y) {
x <<- y
mx <<- NULL
}
get <- function() {
x                  ## Returns the value of matrix x
}
setinverse <- function(inverse) {
mx <<- inverse
}
getinverse <- function() {
mx
}
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The function cacheSolve checks to see if the inverse of the matrix has
## already been calculated.  If it has, it will access the inverse
## from the cache and print it.  If it has not, it will solve for
## the inverse and then print it. Note that this assignment assumed that the
## matrix would be a square one, and, thus, possible to calcualte the inverse.
## If the matrix is singular (determinant =0), then the solve function will
## return an error message.
cacheSolve <- function(x, ...) {
mx <- x$getinverse()
if(!is.null(mx)) {                       ##inverse already calculated?
message("getting cached data")   ##if yes, then gets cached inverse
return(mx)
}
data <- x$get()
nrow<-nrow(data)
print(paste("number of rows",nrow,sep=" "))
mx <- solve(data, ...)          ## Else, calculates inverse. For this
## assignment, assuming a square mx
x$setinverse(mx)
mx
## Return a matrix that is the inverse of 'x'
}
amatrix = makeCacheMatrix(matrix(c(1,2,3,4), nrow=2, ncol=2))
amatrix$get()
cacheSolve(amatrix)
makeCacheMatrix <- function(x = matrix()) {
mx <- NULL                         ## initializes matrix object
set <- function(y) {
x <<- y
mx <<- NULL
}
get <- function() {
x                  ## Returns the value of matrix x
}
setinverse <- function(inverse) {
mx <<- inverse
}
getinverse <- function() {
mx
}
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The function cacheSolve checks to see if the inverse of the matrix has
## already been calculated.  If it has, it will access the inverse
## from the cache and print it.  If it has not, it will solve for
## the inverse and then print it. Note that this assignment assumed that the
## matrix would be a square one, and, thus, possible to calcualte the inverse.
## If the matrix is singular (determinant =0), then the solve function will
## return an error message.
cacheSolve <- function(x, ...) {
mx <- x$getinverse()
if(!is.null(mx)) {                       ##inverse already calculated?
message("getting cached data")   ##if yes, then gets cached inverse
return(mx)
}
data <- x$get()
if (nrow(data)==ncol(data)) {
mx <- solve(data, ...)          ## Else, calculates inverse. For this
## assignment, assuming a square mx
x$setinverse(mx)
mx
} else { print("matrix not square")}
## Return a matrix that is the inverse of 'x'
}
amatrix = makeCacheMatrix(matrix(c(1,2,3,4), nrow=2, ncol=2))
amatrix$get()
cacheSolve(amatrix)
amatrix = makeCacheMatrix(matrix(c(1,2,3,4,5,6), nrow=2, ncol=3))
amatrix$get()
cacheSolve(amatrix)
makeCacheMatrix <- function(x = matrix()) {
mx <- NULL                         ## initializes matrix object
set <- function(y) {
x <<- y
mx <<- NULL
}
get <- function() {
x                  ## Returns the value of matrix x
}
setinverse <- function(inverse) {
mx <<- inverse
}
getinverse <- function() {
mx
}
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The function cacheSolve checks to see if the inverse of the matrix has
## already been calculated.  If it has, it will access the inverse
## from the cache and print it.  If it has not, it will solve for
## the inverse and then print it. Note that this assignment assumed that the
## matrix would be a square one, and, thus, possible to calcualte the inverse.
## If the matrix is singular (determinant =0), then the solve function will
## return an error message.
cacheSolve <- function(x, ...) {
mx <- x$getinverse()
if(!is.null(mx)) {                       ##inverse already calculated?
message("getting cached data")   ##if yes, then gets cached inverse
return(mx)
}
data <- x$get()
if (nrow(data)==ncol(data)) {
mx <- solve(data, ...)          ## Else, calculates inverse. For this
## assignment, assuming a square mx
x$setinverse(mx)
mx
} else { message("matrix not square")}
## Return a matrix that is the inverse of 'x'
}
amatrix = makeCacheMatrix(matrix(c(1,2,3,4,5,6), nrow=2, ncol=3))
amatrix$get()
cacheSolve
cacheSolve(amatrix)
makeCacheMatrix <- function(x = matrix()) {
mx <- NULL                         ## initializes matrix object
set <- function(y) {
x <<- y
mx <<- NULL
}
get <- function() {
x                  ## Returns the matrix x
}
setinverse <- function(inverse) {
mx <<- inverse
}
getinverse <- function() {
mx
}
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The function cacheSolve checks to see if the inverse of the matrix has
## already been calculated.  If it has, it will access the inverse
## from the cache and print it.  If it has not, it will solve for
## the inverse and then print it. Note that this assignment assumed that the
## matrix would be a square one, and, thus, possible to calcualte the inverse.
## If the matrix is singular (determinant =0), then the solve function will
## return an error message.
cacheSolve <- function(x, ...) {
mx <- x$getinverse()
if(!is.null(mx)) {                       ##inverse already calculated?
message("getting cached data")   ##if yes, then gets cached inverse
return(mx)
}
data <- x$get()                         ## Else, calculates inverse
if (nrow(data)==ncol(data)) {           ## Verifies matrix is square
mx <- solve(data, ...)
x$setinverse(mx)
mx
} else { message("matrix not square")}   ## if matrix not square,
## then prints message
}
amatrix = makeCacheMatrix(matrix(c(1,2,3,4), nrow=2, ncol=2))
amatrix$get()
cacheSolve(amatrix)
amatrix$getinverse()
cacheSolve(amatrix)
amatrix$set(matrix(c(0,5,99,66), nrow=2, ncol=2))
cacheSolve(amatrix)
amatrix$get()
amatrix$getinverse()
amatrix$set(matrix(c(0,5,99,66, 75, 75), nrow=3, ncol=2))
amatrix$get()
cacheSolve(amatrix)
amatrix$set(matrix(c(1:9), nrow=3, ncol=3))
amatrix$get()
cacheSolve(amatrix)
testmx <- matrix(c(1:9), nrow=3, ncol=3)
det <- det(testmx)
det
testmx = matrix(c(1:4, nrow=2,ncol=2))
det <- det(testmx)
testmx = matrix(c(1:4), nrow=2,ncol=2))
testmx = matrix(c(1:4), nrow=2,ncol=2)
det <- det(testmx)
det
if (nrow(testmx)== ncol(testmx) && det(testmx) != 0)
solve(testmx)
testmx
if (nrow(testmx)== ncol(testmx) & det(testmx) != 0) solve(testmx)
makeCacheMatrix <- function(x = matrix()) {
mx <- NULL                         ## initializes matrix object
set <- function(y) {
x <<- y
mx <<- NULL
}
get <- function() {
x                  ## Returns the matrix x
}
setinverse <- function(inverse) {
mx <<- inverse
}
getinverse <- function() {
mx
}
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The function cacheSolve checks to see if the inverse of the matrix has
## already been calculated.  If it has, it will access the inverse
## from the cache and print it.  If it has not, it will solve for
## the inverse and then print it. Note that this assignment assumed that the
## matrix would be a square one, and, thus, possible to calcualte the inverse.
## If the matrix is singular (determinant =0), then the solve function will
## return an error message.
cacheSolve <- function(x, ...) {
mx <- x$getinverse()
if(!is.null(mx)) {                       ##inverse already calculated?
message("getting cached data")   ##if yes, then gets cached inverse
return(mx)
}
data <- x$get()                         ## Else, calculates inverse
if (nrow(data)==ncol(data)) {          ## Verifies matrix is square
if (det(data) != 0)  {          ## verifies mx nonsingular
mx <- solve(data, ...)
x$setinverse(mx)
mx
} else {message("determinant =0")}
} else { message("matrix not square")}   ## if matrix not square,
## then prints message
}
amatrix$set(matrix(c(0,5,99,66), nrow=2, ncol=2))
amatrix$get()
cacheSolve(amatrix)
amatrix$get()
cacheSolve(amatrix)
amatrix$set(matrix(c(0,5,99,66, 75,84), nrow=3, ncol=2))
cacheSolve(amatrix)
amatrix$set(matrix(c(1:9), nrow=3, ncol=3))
cacheSolve(amatrix)
